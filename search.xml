<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[note]]></title>
    <url>%2F2018%2F09%2F23%2Fnote%2F</url>
    <content type="text"><![CDATA[范式1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。（R中所有的属性的域都是原子的。） 2、第二范式（2NF）：满足第一范式，然后消除部分依赖。 3、第三范式（3NF）： 满足第二范式，消除传递依赖。 1）1NF：关系中的所以属性值都是不可分割的原子值； 2）2NF：如果关系是1NF，且每个非主属性都完全依赖于候选键； 3）3NF：如果关系是1NF，且每个非主属性都不传递依赖于候选键； 4）BCNF：如果关系是1NF，且每个属性都不传递依赖于候选键。 1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。 2、第二范式（2NF）：关系模式R属于第一范式，且每个非主属性都完全函数依赖于键码。 3、第三范式（3NF）：关系模式R属于第一范式，且每个非主属性都不伟递依赖于键码。 4、 BC范式（BCNF）：关系模式R属于第一范式，且每个属性都不传递依赖于键码。 事务隔离级别未提交读：允许读取未提交数据 已提交读：只允许读取已提交数据，但不要求可重复读 （Oracle默认级别） 可重复读：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据（MySQL默认级别） 可串行化：通常保证可串行化调度 事务特性事务：是访问并可能更新各种数据项的一个程序执行单元 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映 一致性：隔离执行事务时保持数据库的一致性 隔离性：事务之间互不影响，每个事务感觉不到系统中有其他事务在并发地执行 持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障 其他脏读：一个事务可以读取另一个尚未提交事务的修改数据 不可重复读：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时，这一行数据已经发送修改，可能被更新了，也可能被删除了 幻读：在同一个事务中，同一个查询多次进行时，由于其他插入操作的事务提交，导致每次返回不同的结果集 MySQLInnodb：事务安全型，行级锁，适用于insert和update操作，全表扫描计数行数，支持外键，delete时一行一行删除 MyISAM：非事务安全型，表级锁，适用于select，可读取保存好的行数，不支持外键，delete时直接drop再create表]]></content>
  </entry>
  <entry>
    <title><![CDATA[algorithum]]></title>
    <url>%2F2018%2F09%2F22%2Falgorithum%2F</url>
    <content type="text"><![CDATA[###Map用法： map&lt;string, int&gt; mp; map&lt;string, int&gt;::iterator iter; mp[“123”]=1; mp[“456”]=2; mp[“789”]=2; mp[“111”]=2; mp[“222”]=2; for(iter=mp.begin();iter!=mp.end();iter++){ cout &lt;&lt; iter-&gt;first &lt;&lt; “ “ &lt;&lt; iter-&gt;second &lt;&lt; endl; } ###set用法： set s; set::iterator iter; ###素数表： memset(s_x,1,sizeof(s_x)); memset(g_s,0,sizeof(g_s)); for (i = 2; i &lt; k;i++) { if (s_x[i]) for (j = i*i; j &lt; N; j += i) s_x[j] = 0; } ###TreeMap： TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { map.put(i, i*i); } Integer index = (Integer)map.floorKey(5);//方法调用返回的最大键小于等于key，或者null，如果不存在这样的键。 ###stringstream stringstream ss; char s=’A’; ss &lt;&lt; s; cout &lt;&lt; ss.str()&lt;&lt; endl; ss.str(“”);//清空 char buf[10]; string str(&quot;ABCDEFG&quot;); length = str.copy(buf, 9); buf[length] = &apos;\0&apos;; ###大数类 import java.math.BigInteger; public class test { public static void main(String[] args) { BigInteger bi1=new BigInteger(&quot;100&quot;); BigInteger bi2=new BigInteger(&quot;2&quot;); System.out.println(bi1.add(bi2)); //+ System.out.println(bi1.subtract(bi2)); //- System.out.println(bi1.multiply(bi2)); //* System.out.println(bi1.divide(bi2)); //(除) BigInteger[] arr=bi1.divideAndRemainder(bi2); //取除数和余数 for(int i=0;i&lt;arr.length;i++){ System.out.println(arr[i]); } } } 输出： 102 98 200 50 50 0]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring源码下载地址]]></title>
    <url>%2F2018%2F01%2F22%2Fspring%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[https://github.com/spring-projects/spring-framework/tags]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx+Tomcat配置负载均衡]]></title>
    <url>%2F2018%2F01%2F20%2FNginx-Tomcat%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[一、准备工作(1)下载Tomcat8.5,网址： https://tomcat.apache.org/download-80.cgi(2)下载Nginx，网址：http://nginx.org/en/download.html 二、配置Tomcat(1)将下载好的Tomcat解压并命名为Tomcat1，复制Tomcat1至当前目录并重命名为Tomcat2(2)打开~/Tomcat1/conf/server.xml文件，修改三个端口值(可修改为其他值，只要未被占用即可)对~/Tomcat2/conf/server.xml文件进行上述相同的操作，端口值依次改为：8205 8280 8209(3)在两个Tomcat的webapps/ROOT/下新建success.jsp文件，文件内容依次为：(4)启动Tomcat测试：在Tomcat1的bin目录下双击startup.bat启动Tomcatps:如果之前安装过Tomcat且配置到系统环境中，这里双击会打开之前的Tomcat版本,解决方法：用记事本或其他编辑器打开startup.bat自定义CATALINA_HOME值，set “CATALINA_HOME=Tomcat1所在目录\Tomcat1”,再双击startup.bat即可。在浏览器上访问：localhost:8180/success.jsp,会显示tomcat1同样对Tomcat2进行上述操作。 三、配置Nginx将下载好的Nginx解压，打开~/conf/nginx.conf文件，相关配置如下：upstream后面的hello.com必须和location中的hello.com相一致,server后面的URL与两个Tomcat的相对应；upstream中的weight是权重server中listen的端口号根据实际情况选择修改 四、测试启动Nginx:在Nginx目录下打开命令行，输入start nginx两个Tomcat之前的方法开启在浏览器上访问localhost:8089/success.jsp,会显示和tomcat1或tomcat2，多刷新几次，会发现tomcat1的次数与tomcat2的次数比值为：2：5 版权声明：未经许可，禁止转载]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk环境配置]]></title>
    <url>%2F2018%2F01%2F13%2Fjdk%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[准备工作：安装好jdk，并知晓jdk安装的路径1.计算机（右击）→属性→高级系统设置→高级→环境变量，或者win键+pausebreak→高级系统设置→高级→环境变量2.在系统变量中点击新建，变量名为JAVA_HOME，变量值为jdk路径（例如：D:\java\jdk1.8.1)3.在系统变量中点击新建，变量名为CLASSPATH，变量值为.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar(开头的点不要忘了)4.在系统变量中找到Path，点击编辑，在变量值后面加上;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;(开头的分号不要忘了)5.打开cmd，输入java -version测试是否配置成功，成功会显示jdk版本信息]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio 3.0 AAPT2编译报错]]></title>
    <url>%2F2018%2F01%2F12%2Fandroid-studio-3-0-AAPT2%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[打开项目的中的gradle.properties文件，并在文件末尾加上android.enableAapt2=false，再Sync Now即可.]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jvisualvm插件安装教程]]></title>
    <url>%2F2018%2F01%2F12%2Fjvisualvm%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[jvisualvm是一款JAVA性能分析工具，在jdk的bin目录下，并且可以集成其他的插件安装插件步骤：启动jvisualvm，打开 工具→插件，当你检查更新或查看可用插件时会发现连接不上，因为原先地址已经废弃了，新地址迁移到了github上，访问https://visualvm.github.io/pluginscenters.html 找到对应的插件中心，复制Catalog URL，并在jvisualvm插件的设置中编辑visualvm插件中心，更换原先的URL即可，这时候就会显示可用插件等信息，直接安装即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[String, StringBuffer, StringBuilder的区别]]></title>
    <url>%2F2018%2F01%2F09%2FString-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[比较：String：字符串常量，速度慢StringBuffer：字符串变量，速度较快，线程安全StringBuilder：字符串变量，速度快，线程不安全 适用场景：String：操作少量数据StringBuffer：操作大量数据，多线程StringBuilder：操作大量数据，单线程]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
